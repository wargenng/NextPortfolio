### Part 1: Decorators

#### **Understanding Decorators**

Decorators are a powerful feature in Python that allow you to modify the behavior of a function or method. They are particularly useful when you want to add functionality to existing functions or methods without changing their structure. A decorator is essentially a function that takes another function and extends its behavior without explicitly modifying it.

#### **Common Uses of Decorators**

-   **Logging:** To keep track of function usage or certain actions within functions.
-   **Access control:** To restrict access to certain parts of the code.
-   **Caching:** To store the results of expensive function calls and reuse them when the same inputs occur again.
-   **Measurement:** To track the time a function takes to execute.

#### **Class-Related Decorators**

Python provides several built-in decorators that are commonly used with class methods:

-   `@staticmethod`: Indicates that a method is a static method, which means it does not receive an implicit first argument (typically `self` for instance methods or `cls` for class methods).
-   `@classmethod`: Transforms a method into a class method, which receives the class as the first argument instead of an instance of the class.
-   `@property`: Allows a method to be accessed like an attribute instead of as a method with a call syntax.

#### **Live Coding Example**

Let's see a basic example of a decorator in action. Here, we define a decorator that logs the before and after states of a function call:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Something is happening before the function is called.")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    print(f"Hello {name}")

say_hello("Alice")
```

This example demonstrates how decorators wrap a function, modifying its behavior. Here, the `say_hello` function is wrapped so that it outputs additional lines of text before and after the greeting.

#### **Exercise: Log Decorator**

Now, let's apply what you've learned by writing a decorator that logs every time a method is called within a class. This is particularly useful for debugging and understanding how often and when methods are executed:

```python
def log_method_call(func):
    def wrapper(self, *args, **kwargs):
        print(f"Calling {func.__name__} with {args} and {kwargs}")
        return func(self, *args, **kwargs)
    return wrapper

class Greeting:
    @log_method_call
    def greet(self, name):
        print(f"Hi {name}, how are you?")

g = Greeting()
g.greet("Alice")
```

This exercise will help you see how decorators can be used in classes to enhance functionality, such as logging method calls. It's a practical tool for monitoring class behavior during development and production.
